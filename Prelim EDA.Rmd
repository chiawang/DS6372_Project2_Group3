---
title: "Prelim EDA"
author: "Stats 2 Project Team"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(tidyverse)
library(naniar)
library(questionr)
library(rebus)
library(GGally)
library(gridExtra)
library(caret)
library(randomForest)
library(ROCR)
library(glmnet)
library(car)
```

# Background
https://www.hindawi.com/journals/bmri/2014/781670/
http://downloads.hindawi.com/journals/bmri/2014/781670.pdf

To Do: Provide summary of paper, site as reference. 
_Beata Strack, Jonathan P. DeShazo, Chris Gennings, Juan L. Olmo, Sebastian Ventura, Krzysztof J. Cios, and John N. Clore, “Impact of HbA1c Measurement on Hospital Readmission Rates: Analysis of 70,000 Clinical Database Patient Records,” BioMed Research International, vol. 2014, Article ID 781670, 11 pages, 2014._

# Data Set
https://archive.ics.uci.edu/ml/datasets/diabetes+130-us+hospitals+for+years+1999-2008

The following is taken verbatim from above.

The dataset represents 10 years (1999-2008) of clinical care at 130 US hospitals and integrated delivery networks. It includes over 50 features representing patient and hospital outcomes. Information was extracted from the database for encounters that satisfied the following criteria.

* It is an inpatient encounter (a hospital admission).
* It is a diabetic encounter, that is, one during which any kind of diabetes was entered to the system as a diagnosis.
* The length of stay was at least 1 day and at most 14 days.
* Laboratory tests were performed during the encounter.
* Medications were administered during the encounter.

The data contains such attributes as patient number, race, gender, age, admission type, time in hospital, medical specialty of admitting physician, number of lab test performed, HbA1c test result, diagnosis, number of medication, diabetic medications, number of outpatient, inpatient, and emergency visits in the year before the hospitalization, etc.

## Dictionary

To Do: Provide dictionary of elements. This is provided in the paper's pdf. Let's copy it here and reference page 3 of Impact of HbA1c Measurement on Hospital Readmission Rates: Analysis of 70,000 Clinical Database Patient Records pdf document. The table can also be found here,

https://www.hindawi.com/journals/bmri/2014/781670/tab1/

## Import Data
```{r import}
data <- read.csv("./diabetic_data.csv")
head(data)
```

Notice above that we having missing values represented by '?'. Let's replace '?' with NA.

```{r replace_missing}
data <- data %>% mutate_all(~na_if(., '?'))
```

Check variables with missing values.
```{r}
freq.na(data)
```

Due to the frequency of missing data, let's remove 'weight', 'medical_specialty', and 'payer_code'.

```{r}
data <- select(data, select=-c("weight","medical_specialty","payer_code"))
```

Next, let's remove observations where the discharge disposition is related to hospice or death, since these will not add to the possibility of being readmitted.
* 11 - Expired
* 13 - Hospice/Home
* 14 - Hospice/Medical Facility
* 19 - Expired at Home
* 20 - Expired at Medical Facility
* 21 - Expired at Unknown

```{r discharge}
data <- data %>% filter(!data$discharge_disposition_id %in% c('11','13','14','19','20','21'))
```

In the data set, we find that patients have multiple admissions. The paper suggests using only the first one to satisfy the independence assumption. So we will filter and only use the first encounter (the lowest for a given member). I wonder if this could be challenged. If the diagnosis or reason for visit is different than a previous admission, I think it could be considered statisically independent.

```{r oneEncounter}
data <- data %>% group_by(patient_nbr) %>% filter(encounter_id == min(encounter_id))
data <- ungroup(data)
```


Next, let's create buckets for the ICD-9 diagnosis codes. We'll use the mapping defined based on the following.
https://www.hindawi.com/journals/bmri/2014/781670/tab2/

```{r helper}
replaceDX <- function(df = data, rx, replaceValue) {
  df$diag_1[grep(rx,df$diag_1)] <- replaceValue
  df$diag_2[grep(rx,df$diag_2)] <- replaceValue
  df$diag_3[grep(rx,df$diag_3)] <- replaceValue
  
  return(df)
}
```

```{r}
# Create temporary data frame of bucketed DX codes
dx <- c("diag_1","diag_2","diag_3")
dataDX <- data[dx]
dataDX[] <- lapply(data[dx], as.character)

# Circulatory
label <- "Circulatory"
rx <- number_range(390,459)
dataDX <- replaceDX(dataDX, rx, label)
dataDX <- replaceDX(dataDX, "785", label)

# Respiratory
label <- "Respiratory"
rx <- number_range(460,519)
dataDX <- replaceDX(dataDX, rx, label)
dataDX <- replaceDX(dataDX, "786", label)

# Digestive
label <- "Digestive"
rx <- number_range(520,579)
dataDX <- replaceDX(dataDX, rx, label)
dataDX <- replaceDX(dataDX, "787", label)

# Diabetes
label <- "Diabetes"
rx <- number_range(250,250.99)
dataDX <- replaceDX(dataDX, rx, label)

# Injury
label <- "Injury"
rx <- number_range(800,999)
dataDX <- replaceDX(dataDX, rx, label)

# Musculoskeletal
label <- "Musculoskeletal"
rx <- number_range(710,739)
dataDX <- replaceDX(dataDX, rx, label)

# Genitourinary
label <- "Genitourinary"
rx <- number_range(580,629)
dataDX <- replaceDX(dataDX, rx, label)
dataDX <- replaceDX(dataDX, "788", label)

# Neoplasms
label <- "Neoplasms"

rx <- number_range(140,239)
dataDX <- replaceDX(dataDX, rx, label)

rx <- number_range(780,782)
dataDX <- replaceDX(dataDX, rx, label)
dataDX <- replaceDX(dataDX, "784", label)

rx <- number_range(790,799)
dataDX <- replaceDX(dataDX, rx, label)

rx <- number_range(240,279)
dataDX <- replaceDX(dataDX, rx, label)

rx <- number_range(680,709)
dataDX <- replaceDX(dataDX, rx, label)

# Number range here doesn't work as I would expect, probably because it spans 1 to 3 digits
# So I'll just create my own regEx object
# rx <- number_range(1,139)
rx <- regex("(?:^([1-9]|[1-8][0-9]|9[0-9]|1[0-2][0-9]|13[0-9])$)")
dataDX <- replaceDX(dataDX, rx, label)

# Other
label = "Other"

rx = "^E.*"
dataDX <- replaceDX(dataDX, rx, label)
rx = "^V.*"
dataDX <- replaceDX(dataDX, rx, label)

rx <- number_range(290,319)
dataDX <- replaceDX(dataDX, rx, label)

rx <- number_range(280,289)
dataDX <- replaceDX(dataDX, rx, label)

rx <- number_range(320,359)
dataDX <- replaceDX(dataDX, rx, label)

rx <- number_range(630,679)
dataDX <- replaceDX(dataDX, rx, label)

rx <- number_range(360,389)
dataDX <- replaceDX(dataDX, rx, label)

rx <- number_range(740,759)
dataDX <- replaceDX(dataDX, rx, label)
dataDX <- replaceDX(dataDX, "783", label)
dataDX <- replaceDX(dataDX, "789", label)

#If value is "NA", we'll replace with "None"
#dataDX <- replace_na(dataDX,"None")

# Now update main data table and set DX buckets as factors. Replace NA with None
dataDX <- lapply(dataDX,replace_na,"None")
data[dx] <- lapply(dataDX, as.factor)
```

```{r}
# Use plyr here, it looks better
plyr::count(data$diag_1)
```

Age is a factor with 10 levels. We are going to bucket these into 3 different groups in a new feature, and remove the old feature.

* 0 - 30
* 30 - 60
* 60 - 100

```{r}
data[which(data$age=="[0-10)"),c("ageGrp")] <- "[0-30]"
data[which(data$age=="[10-20)"),c("ageGrp")] <- "[0-30]"
data[which(data$age=="[20-30)"),c("ageGrp")] <- "[0-30]"
data[which(data$age=="[30-40)"),c("ageGrp")] <- "[30-60]"
data[which(data$age=="[40-50)"),c("ageGrp")] <- "[30-60]"
data[which(data$age=="[50-60)"),c("ageGrp")] <- "[30-60]"
data[is.na(data$ageGrp),c("ageGrp")] <- "[60-100]"
data$ageGrp <- as.factor(data$ageGrp)

# Remove old feature
data <- select(data, select=-c("age"))
```

Convert features with numerals as factors. Perhaps it would be better to convert these to their actual names.
```{r}
data$admission_type_id <- as.factor(data$admission_type_id)
data$discharge_disposition_id <- as.factor(data$discharge_disposition_id)
data$admission_source_id <- as.factor(data$admission_source_id)
```

There are two medications that have only 1 factor level, "examide" and "citoglipton". We will remove these from the data set.
```{r}
data <- select(data, select=-c("examide","citoglipton"))
```

Since encounter_id and patient_nbr are identifiers, we will remove these as well.
```{r}
# We need to ungroup by patient_nbr since we grouped by it earlier.
data <- select(data, select=-c("encounter_id","patient_nbr"))
```

Clean up Race feature NAs and label as "Missing"
```{r}
levels(data$race) <- c(levels(data$race), "Missing")
data$race <- replace_na(data$race, "Missing")
```



Lastly, let's create an outcome column that is Yes if admitted within 30 days, and No for everything else. Then remove the readmitted column. We'll use "outcome" as the response variable.
```{r}
data$outcome <- factor(ifelse(data$readmitted == "<30","Yes","No"))
data <- select(data, select=-c("readmitted"))
plyr::count(data$outcome)
```

Above we see that about 10% of our data shows as readmitted, so we have an inbalanced data set. Need to consider that in our analysis. See 
https://towardsdatascience.com/methods-for-dealing-with-imbalanced-data-5b761be45a18

The final dataset consists of 69,990 observations with 43 features.

### Proportion Plots

#### Age

* The bulk of the patients are in the age range of 40 - 90 years.
* The proportion of readimts increase from the lowest bucket up to the 80s bucket.

```{r, fig.width=12}
p1 <- data %>%
  ggplot(aes(x = ageGrp)) +
  geom_bar()
p2 <- data %>%
  ggplot(aes(x = ageGrp, fill = outcome)) +
  geom_bar(position = 'fill') +
  coord_flip()
grid.arrange(p1, p2, ncol = 2)
```


#### Time in Hospital

This is the number of days a patient spent in the hospital.
The distribution is at max at 3 days, then tails off at the time increases.
Maximum observed value is 14 days.

```{r}
p1 <- data %>%
  ggplot(aes(x = time_in_hospital)) +
  geom_bar()
p2 <- data %>%
  ggplot(aes(x = time_in_hospital, fill = outcome)) +
  geom_bar(position = 'fill') +
  coord_flip()
p3 <- data %>%
  ggplot(aes(x = outcome, y = time_in_hospital)) +
  geom_boxplot()
grid.arrange(p1, p2, p3, ncol = 2)
```

#### Number of Diagnoses

There seem to be a correlation between readmittance and number of diagnoses.

```{r}
p1 <- data %>%
  ggplot(aes(x = number_diagnoses)) +
  geom_histogram(bins = 30) 
p2 <- data %>%
  ggplot(aes(y = number_diagnoses)) +
  geom_boxplot() +
  facet_wrap(. ~ outcome)
p3 <- data %>%
  ggplot(aes(x = number_diagnoses, fill = outcome)) +
  geom_bar(position = 'fill') +
  coord_flip()
grid.arrange(p1, p2, p3, ncol = 2)
```

#### Race vs. Readmission
There seem to be a correlation between readmittance and race.

```{r}
# readmission within 30 days
data$outcome <- factor(ifelse(data$readmitted == "<30","Yes","No"))

readmission_vs_race <- table(data$outcome,data$race)

barplot(readmission_vs_race,col=c("#009E73","#D55E00"), legend = rownames(readmission_vs_race), xlab = "Race", ylab="Diabetic Patient Number", main= "Re-admission within 30 days vs Race")
```

## Modeling

Let's try some different modeling options. Since we have an imbalanced data set, there are different things we can try. Let's start with down sampling.

### Down Sample

```{r}
trainIdx <- createDataPartition(data$outcome, p =0.75, list = F, times = 1)
train <- data[trainIdx, ]
test <- data[-trainIdx, ]

set.seed(9560)
train <- downSample(x = train[, -ncol(train)],
                    y = train$outcome, yname="outcome")

train.y = train$outcome
train.x = train[,-ncol(train)]

test.y = test$outcome
test.x = test[,-ncol(test)]
```

### Random Forest Example
https://machinelearningmastery.com/tune-machine-learning-algorithms-in-r/

Training Set
```{r}
train.rf<-randomForest(outcome~.,data=train,importance=T)
fit.pred<-predict(train.rf,newdata=train,type="prob")

pred <- prediction(fit.pred[,2], train$outcome)
roc.perf = performance(pred, measure = "tpr", x.measure = "fpr")
auc.train <- performance(pred, measure = "auc")
auc.train <- auc.train@y.values
plot(roc.perf)
abline(a=0, b= 1)
text(x = .40, y = .6,paste("AUC = ", round(auc.train[[1]],3), sep = ""))
```


Test Set
```{r}
pred.val1<-predict(train.rf,newdata=test,type="prob")
pred <- prediction(pred.val1[,2], test$outcome)
roc.perf = performance(pred, measure = "tpr", x.measure = "fpr")
auc.test <- performance(pred, measure = "auc")
auc.test <- auc.test@y.values
plot(roc.perf)
abline(a=0, b=1)
text(x = .4, y = .6,paste("AUC = ", round(auc.test[[1]],3), sep = ""))
```

**Gini importances plot**

Gini has to do with the cross-entroy of the trees from a split. Decreases in Gini index are desirable.

https://towardsdatascience.com/seeing-the-random-forest-from-the-decision-trees-an-intuitive-explanation-of-random-forest-beaa2d6a0d80

ISL p.312

https://stats.stackexchange.com/questions/92419/relative-importance-of-a-set-of-predictors-in-a-random-forests-classification-in

```{r}
importance(train.rf)

rf.feature.importance <- data.frame(importance(train.rf))

varimp1 <- rf.feature.importance[order(rf.feature.importance$MeanDecreaseGini,decreasing = T),]

varimp1

par(mar=c(10,5,1,1)) 
giniplot <- barplot(t(varimp1[-2]/sum(varimp1[-2])), las=2, cex.names=1,
                    main="Gini Impurity Index Plot")

giniplot <- barplot(t(varimp1[-2]/sum(varimp1[-2])), las=2, cex.names=1,
                    main="Gini Impurity Index Plot")
```

Sampling Tuning Test
```{r}
bestmtry <- tuneRF(train.x, train.y, stepFactor=.5, improve=1e-5, ntree=500)
print(bestmtry)
```

### Logistic Example
```{r}
#glmnet requires a matrix 
train.x <- data.matrix(train.x)
cvfit <- cv.glmnet(train.x,train.y, family = "binomial", type.measure = "class", nlambda = 1000)
plot(cvfit)
coef(cvfit, s = "lambda.min")

#Get training set predictions...We know they are biased but lets create ROC's.
#These are predicted probabilities from logistic model  exp(b)/(1+exp(b))
fit.pred <- predict(cvfit, newx = train.x, type = "response")

#Compare the prediction to the real outcome
head(fit.pred)
head(train.y)

#Create ROC curves
pred <- prediction(fit.pred[,1], train.y)
roc.perf = performance(pred, measure = "tpr", x.measure = "fpr")
auc.train <- performance(pred, measure = "auc")
auc.train <- auc.train@y.values

#Plot ROC
plot(roc.perf)
abline(a=0, b= 1) #Ref line indicating poor performance
text(x = .40, y = .6,paste("AUC = ", round(auc.train[[1]],3), sep = ""))
```


Run model against test set
```{r}
#Run model from training set on valid set I
test.x <- data.matrix(test.x)
fit.pred1 <- predict(cvfit, newx = test.x, type = "response")

#ROC curves
pred1 <- prediction(fit.pred1[,1], test.y)
roc.perf1 = performance(pred1, measure = "tpr", x.measure = "fpr")
auc.val1 <- performance(pred1, measure = "auc")
auc.val1 <- auc.val1@y.values
plot(roc.perf1)
abline(a=0, b= 1)
text(x = .40, y = .6,paste("AUC = ", round(auc.val1[[1]],3), sep = ""))
```


### HeatMap
```{r}
ggplot(data = data,aes(x = data$race, y = data$age)) +labs(title="(Race & Age) Vs Readmission", y="Patient Age Group", x="Race")+geom_tile(aes(fill = data$readmitted))

ggplot(data = data, aes(x = data$time_in_hospital, y = data$age)) + labs(title="(Time in hospital & Age) Vs Readmission", y="Patient Age Group", x="Time in hospital") + geom_tile(aes(fill = data$readmitted))

ggplot(data = data, aes(x = data$age, y = data$diag_1)) + labs(title="(Age & Diag_1) Vs Readmission", y="Patient Age Group", x="Daig_1") + geom_tile(aes(fill = data$readmitted))

ggplot(data = data, aes(x = data$age, y = data$diag_2)) + labs(title="(Age & Diag_2) Vs Readmission", y="Patient Age Group", x="Daig_2") + geom_tile(aes(fill = data$readmitted))

ggplot(data = data, aes(x = data$age, y = data$diag_3)) + labs(title="(Age & Diag_3) Vs Readmission", y="Patient Age Group", x="Daig_3") + geom_tile(aes(fill = data$readmitted))

```











